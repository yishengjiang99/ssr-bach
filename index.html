<!DOCTYPE html>
<html>
  <head>
    <script src="lib/miditone.js"></script>
  </head>

  <body style="display: grid; place-items: center">
    <span id="prog"
      ><label></label><progress value="0" max="0"></progress
    ></span>
    <main>
      <pre></pre>
      <button disabled>start</button>
      <button disabled>stop</button>
    </main>
    <script
      schema="https://github.com/guest271314/AudioWorkletStream/blob/shared-memory-audio-worklet-stream/index.html"
      type="template/javascript"
      id="workletcode"
    >
      import {Runtime} from "https://www.grepawk.com/ssr-bach/rt-bundle.js"; //runtime.js";
          const sampleRate = 48000;
          //@ts-ignore
          class RenderProcessor extends AudioWorkletProcessor {
              constructor(options) {
                  super();
                  this.staging = [];
                  this.production = new Array(16);
                  this.port.onmessage = (e) => {
                      const { samples, zone, note } = e.data;
                      if (samples) {
                          this.samples = new Float32Array(samples);
                          this.startTime = globalThis.currentTime;
                          this.port.postMessage({ ready: 1 });
                      }
                      if (zone && note) {
                        const sampleData=({start,end})=>this.samples.subarray(start,end);
                          const { start, channelId } = note;
                          const rt = new Runtime(zone, {
                              key: note.midi,
                              velocity: note.velocity,
                              channel: channelId,
                          });
                          this.staging.push({
                              channelId,
                              note,
                              rt,
                              sampleData: this.samples.subarray(zone.sample.start,zone.sample.end),
                              shift: 0.0,
                              get startFrame() {
                                  if (this.startTime == null)
                                      return false;
                                  return (start - this.startTime) / sampleRate;
                              },
                          });

                      }
                  };
              }
              process(inputs, outputs, parameters) {
                  while (this.staging[0]?.startFrame < globalThis.currentFrame + 128) {
                      const v = this.staging.shift();
                      v.preroll = ~~(v.startFrame - globalThis.currentFrame);
                      this.production[v.channelId] = v;
                  }
                  for (let vid = 0; vid < 17; vid++) {
                      if (!this.production[vid])
                          continue;
                      const v = this.production[vid];
                      let { preroll } = v;
                      //    const rootkey =v.rt.zone.rootKey >-1 ?v.rt.zone.rootKey :v.rt.zone.sample.originalPitch;
                      const { pitch, volume } = v.rt.run(128);
                      const pan = v.rt.staticLevels.pan;
                      let iterator = v.rt.iterator;
                      const looper = v.rt.sample.end - v.rt.sample.start;
                      for (let offset = 0; offset < 128; offset++) {
                          let newval;
                          if (preroll-- > 0) {
                              newval = 0;
                              continue;
                          }
                          else {
                              newval = this.samples[iterator];
                          }
                          newval = newval * volume;
                          outputs[0][0][offset] += newval * pan.left;
                          outputs[0][1][offset] += newval * pan.right;
                          v.shift = v.shift + pitch;
                          while (v.shift >= 1) {
                            iterator++;
                              v.shift--;
                          }
                          if (iterator >= v.rt.sample.endLoop) {
                            iterator = iterator- looper;
                          }
                      }
                      v.rt.iterator=iterator;
                  }
                  return true;
              }
          }
          // @ts-ignore
          registerProcessor('rend-proc', RenderProcessor);
    </script>
    <script type="module">
      import { h, mlist, pdtaView } from './dist/react-light.js';
      import { initsfbk } from './dist/sfbk.js';
      const maindiv = document.querySelector('main').appendChild(mlist);
      let sdta, _sdtaWait, timer, _pdta, proc, ctx;
      let playing = false;
      const midiurls = [
        // 'c.mid',

        'midi/serenade_k361_3rd-mid.mid',
      ];
      const workletcode = URL.createObjectURL(
        new Blob([document.getElementById('workletcode').textContent], {
          type: 'text/javascript',
        })
      );
      const [playBtn, stopbtn] = document.querySelectorAll('button');

      const ch = new MessageChannel();
      const cosole = document.querySelector('pre');
      const div = document.querySelector('pre');
      const logs = [];

      const loghtml = (...entry) => {
        logs.push(entry.join('\t'));
        cosole.innerHTML = logs.join('\n');
        if (logs.length > 90) logs.shift();
      };
      const prog = document.querySelector('#prog progress');
      ch.port1.onmessage = (e) => {
        const {
          data: {
            prog: [n, d],
            msg,
          },
        } = e;

        if (n && d) {
          prog.max = d;
          prog.value = n;
        }
      };
      const sfurls = ['GeneralUserGS.sf2'];

      queueMicrotask(init);

      async function init() {
        const { pdta, sdtaWait } = await initsfbk(sfurls[0], ch.port2);
        _pdta = pdta;
        sdta = await sdtaWait;
        playBtn.removeAttribute('disabled');
      }

      playBtn.addEventListener('click', async (e) => {
        if (!ctx) {
          loghtml('starting.');
          ctx = new AudioContext();
          await ctx.audioWorklet.addModule(workletcode);
          proc = new AudioWorkletNode(ctx, 'rend-proc', {
            outputChannelCount: [2],
          });
          loghtml('got proc.');

          proc.onprocessorerror = (e) => {
            console.trace();
          };
          const procreadyWait = new Promise((resolve) => {
            proc.port.onmessage = (e) => {
              console.log(e);
              resolve();
            };
          });
          proc.port.postMessage({ samples: sdta.buffer }, [sdta.buffer]);
          loghtml('posting samp');
          await procreadyWait;
          await ctx.resume();
          proc.connect(ctx.destination);
          playing = true;
          loghtml('posting samp');

          timer = playMidi(midiurls[0]);
          e.target.setAttribute('disabled', 'true');
          stopbtn.setAttribute('disabled', 'false');
        }
      });
      stopbtn.addEventListener('click', (e) => {
        playing = false;
        e.target.setAttribute('disabled', 'true');
        playBtn.setAttribute('disabled', 'false');
      });

      async function playMidi(url) {
        const { durationTicks, header, tracks } = await Midi.fromUrl(url);
        let t = 1;
        while (t < durationTicks && playing) {
          let output = '';
          const _t = header.secondsToTicks(t / 1000);
          const ratio = t / _t;
          for (let i = 0; i < tracks.length; i++) {
            const track = tracks[i];
            while (
              track.notes &&
              track.notes[0] &&
              track.notes[0].ticks < _t + 230
            ) {
              const note = track.notes.shift();
              const z = _pdta.findPreset(
                track.instrument.number,
                track.instrument.percussion ? 128 : 0,
                note.midi,
                note.velocity * 127
              );

              if (z && z[0]) {
                proc.port.postMessage({
                  zone: z[0].serialize(),
                  note: {
                    midi: note.midi,
                    velocity: note.velocity * 127,
                    start: note.time,
                    durationTime: note.durationTime,
                    channelId: track.channel,
                  },
                });
                console.log(z[0]);
              }
            }
            t += 200;
            await new Promise((r) => setTimeout(r, 200));
            if (output) pre.innerHTML = output;
          }
        }
      }
    </script>
  </body>
</html>
