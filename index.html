<!DOCTYPE html>
<html>
  <head>
    <script src="lib/miditone.js"></script>
  </head>

  <body>
    <span id="prog"
      ><label></label><progress value="0" max="0"></progress
    ></span>
    <main>
      <pre></pre>
      <button>start</button>
    </main>
    <script
      schema="https://github.com/guest271314/AudioWorkletStream/blob/shared-memory-audio-worklet-stream/index.html"
      type="template/javascript"
      id="workletcode"
    >
      import {Runtime} from "https://dsp.grepawk.com/ssr-bach/rt-bundle.js"; //runtime.js";
          const sampleRate = 48000;
          //@ts-ignore
          class RenderProcessor extends AudioWorkletProcessor {
              constructor(options) {
                  super();
                  this.staging = [];
                  this.production = new Array(16);
                  this.port.onmessage = (e) => {
                      const { samples, zone, note } = e.data;
                      if (samples) {
                          this.samples = samples;
                          this.startTime = globalThis.currentTime;
                          this.port.postMessage({ ready: 1 });
                      }
                      if (zone && note) {
                        const sampleData=({start,end})=>this.samples.subarray(start,end);
                          const { start, channelId } = note;
                          const rt = new Runtime(zone, {
                              key: note.midi,
                              velocity: note.velocity,
                              channel: channelId,
                          });
                          this.staging.push({
                              channelId,
                              note,
                              rt,
                              sampleData: this.samples.subarray(zone.sample.start,zone.sample.end),
                              shift: 0.0,
                              get startFrame() {
                                  if (this.startTime == null)
                                      return false;
                                  return (start - this.startTime) / sampleRate;
                              },
                          });

                      }
                  };
              }
              process(inputs, outputs, parameters) {
                  while (this.staging[0]?.startFrame < globalThis.currentFrame + 128) {
                      const v = this.staging.shift();
                      v.preroll = ~~(v.startFrame - globalThis.currentFrame);
                      this.production[v.channelId] = v;
                  }
                  for (let vid = 0; vid < 17; vid++) {
                      if (!this.production[vid])
                          continue;
                      const v = this.production[vid];
                      let { preroll } = v;
                      //    const rootkey =v.rt.zone.rootKey >-1 ?v.rt.zone.rootKey :v.rt.zone.sample.originalPitch;
                      const { pitch, volume } = v.rt.run(128);
                      const pan = v.rt.staticLevels.pan;
                      let iterator = v.rt.iterator;
                      const looper = v.rt.sample.endLoop - v.rt.sample.startLoop;
                      for (let offset = 0; offset < 128; offset++) {
                          let newval;
                          if (preroll-- > 0) {
                              newval = 0;
                              continue;
                          }
                          else {
                              newval = this.samples[iterator];
                          }
                          newval = newval * volume;
                          outputs[0][0][offset] += newval * pan.left;
                          outputs[0][1][offset] += newval * pan.right;
                          v.shift = v.shift + pitch;
                          while (v.shift >= 1) {
                            iterator++;
                              v.shift--;
                          }
                          if (iterator >= v.rt.sample.endLoop) {
                            iterator = iterator- looper;
                          }
                      }
                      v.rt.iterator=iterator;
                  }
                  return true;
              }
          }
          // @ts-ignore
          registerProcessor('rend-proc', RenderProcessor);
    </script>
    <script src="dist/ghettoreact.js"></script>
    <script type="module">
      import { initsfbk } from './dist/sfbk.js';
      const maindiv = document.querySelector('main');
      const midiurls = [
        // 'c.mid',

        'midi/serenade_k361_3rd-mid.mid',
      ];
      const workletcode = URL.createObjectURL(
        new Blob([document.getElementById('workletcode').textContent], {
          type: 'text/javascript',
        })
      );
      const ch = new MessageChannel();
      const cosole = document.querySelector('pre');
      const prog = document.querySelector('#prog progress');
      ch.port1.onmessage = (e) => {
        const {
          data: {
            prog: [n, d],
            msg,
          },
        } = e;
        console.log(e);
        if (n && d) {
          prog.max = d;
          prog.value = n;
        }
      };
      const sfurls = ['GeneralUserGS.sf2'];
      let sdta, _sdtaWait, timer, _pdta, proc, ctx;
      let playing = false;
      queueMicrotask(init);

      async function init() {
        const { pdta, sdtaWait } = await initsfbk(sfurls[0], ch.port2);
        _pdta = pdta;
        _sdtaWait = sdtaWait;
        displayMidi(midiurls[0], pdta);
      }
      async function initCtx() {
        ctx = new AudioContext();
        sdta = await _sdtaWait;
        await ctx.audioWorklet.addModule(workletcode);
        proc = new AudioWorkletNode(ctx, 'rend-proc', {
          outputChannelCount: [2],
        });

        proc.onprocessorerror = (e) => {
          console.trace();
        };

        proc.port.postMessage({ samples: sdta });
        await new Promise((resolve) => {
          proc.port.onmessage = async (e) => {
            if (e.data.ready == 1) {
              resolve();
            }
          };
        });
        proc.connect(ctx.destination);
        await ctx.resume();
      }

      async function displayMidi(url, pdta) {
        let playing = false;
        const { durationTicks, header, tracks } = await Midi.fromUrl(url);
        async function startstoptoggle(e) {
          if (!ctx) {
            await initCtx();
          }
          if (!playing) {
            playing = true;
            timer = playMidi(durationTicks, header, tracks);
            e.target.innerHTML = 'st0p';
          } else {
            playing = false;
            e.target.innerHTML = 'start';
            clearTimeout(timer);
          }
        }
        const playBtn = document.querySelector('button');
        playBtn.addEventListener('click', startstoptoggle);
        const trackview = (track, pdta) => {
          const patchn = track.instrument.number;
          const preset = pdta.phdr.filter(
            (p) => p.presetId == (patchn & 0x7f) && p.bankId == (patchn & 0x80)
          )[0];
          return h(
            'div',
            {
              presetId: patchn & 0x7f,
              style: 'display:grid;grid-template-columns:1fr 1fr 1fr 1fr',
            },
            [
              h('span', {}, [h('h5', {}, preset.name)]),
              h('span', {}, [
                h('meter', {
                  value: 50,
                  max: 100,
                  min: 0,
                }),
              ]),
            ]
          );
        };
        maindiv.appendChild(
          h('div', {}, [
            playBtn,
            h('pre', {}, []),
            ...tracks.map((t) => trackview(t, pdta)),
          ])
        );
        async function* playMidi(durationTicks, header, tracks) {
          //   const { durationTicks, header, tracks } = await Midi.fromUrl(midiUrl);
          let t = -200;
          while (t < durationTicks && playing) {
            let output = '';
            tracks.map((track, channelId) => {
              const _t = header.secondsToTicks(t / 1000);
              const ratio = t / _t;
              while (
                track.notes &&
                track.notes[0] &&
                track.notes[0].ticks < _t + 211
              ) {
                const note = track.notes.shift();
                const pset = _pdta.findPreset(
                  track.instrument.number,
                  track.instrument.percussion ? 128 : 0,
                  note.midi,
                  note.velocity * 127
                );
                const z = pset.zones;

                if (z[0] && z[0][0]) {
                  proc.port.postMessage({
                    zone: z[0][0].serialize(),
                    note: {
                      midi: note.midi,
                      velocity: note.velocity * 127,
                      start: note.time,
                      durationTime: note.durationTime,
                      channelId: channelId,
                    },
                  });
                }
              }
            });
            t += 200;
            if (output) pre.innerHTML = output;
            yield;
          }
        }
      }
    </script>
  </body>
</html>
