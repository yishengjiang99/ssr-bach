<!DOCTYPE html>
<html>
  <head>
    <script src="lib/miditone.js"></script>
  </head>

  <body>
    <pre></pre>
    <main></main>
    <script type="template" id="rendproc"></script>
    <script src="dist/ghettoreact.js"></script>
    <script type="module">
      import { initsfbk } from './dist/sfbk.js';
      const maindiv = document.querySelector('main');
      const pre = document.querySelector('pre');
      const midiurls = [
        'https://grep32bit.blob.core.windows.net/midi/Beethoven-Symphony5-1.mid',
      ];
      const sfurls = ['GeneralUserGS.sf2'];
      const selects = document.querySelectorAll('select');
      let worker, ctx, timer, _pdta;
      queueMicrotask(() => {
        initsfbk(sfurls[0]).then(({ pdta, workerWait }) => {
          _pdta = pdta;
          displayMidi(midiurls[0], pdta, workerWait);
        });
      });
      async function displayMidi(url, pdta, workerWait) {
        let playing = false;
        const { durationTicks, header, tracks } = await Midi.fromUrl(url);
        const selectView = (presetId, pdta) =>
          h(
            'select',
            {
              value: presetId,
              oninput: (e) =>
                e.target.parentElement.setAttribute('presetId', e.target.value),
            },
            pdta.phdr.map((p) => h('option', { value: p.presetId }, p.name))
          );
        const playBtn = () =>
          h(
            'button',
            {
              onclick: async (e) => {
                ctx = ctx || new AudioContext();

                if (!worker) {
                  worker = (await workerWait).worker;
                }
                if (!playing) {
                  playing = true;
                  timer = playMidi(durationTicks, header, tracks);
                  e.target.innerHTML = 'st0p';
                } else {
                  playing = false;
                  e.target.innerHTML = 'start';
                }
              },
            },
            'start'
          );
        const trackview = (track, pdta) => {
          const patchn = track.instrument.number;
          const preset = pdta.phdr.filter(
            (p) => p.presetId == (patchn & 0x7f) && p.bankId == (patchn & 0x80)
          )[0];
          return h(
            'div',
            {
              presetId: patchn & 0x7f,
              style: 'display:grid;grid-template-columns:1fr 1fr 1fr 1fr',
            },
            [
              h('span', {}, [
                h('h5', {}, preset.name),
                selectView(preset.presetId, pdta),
              ]),

              h('span', {}, [
                h('meter', {
                  value: 50,
                  max: 100,
                  min: 0,
                }),
              ]),
            ]
          );
        };
        maindiv.appendChild(
          h('div', {}, [playBtn(), ...tracks.map((t) => trackview(t, pdta))])
        );

        async function playMidi(durationTicks, header, tracks) {
          //   const { durationTicks, header, tracks } = await Midi.fromUrl(midiUrl);
          let t = -200;
          while (t < durationTicks && playing) {
            let output = '';
            tracks.map((track) => {
              const _t = header.secondsToTicks(t / 1000);
              const ratio = t / _t;
              while (
                track.notes &&
                track.notes[0] &&
                track.notes[0].ticks < _t + 230
              ) {
                const note = track.notes.shift();
                const pset = _pdta.findPreset(
                  track.instrument.number,
                  track.instrument.percussion ? 128 : 0,
                  note.midi,
                  note.velocity * 127
                );
                pset.zones[0].map((z) => {
                  output +=
                    '\n' +
                    [
                      ((note.ticks - _t) * ratio).toFixed(1),
                      track.instrument.number,
                      track.instrument.percussion ? 128 : 0,
                      note.midi,
                      note.velocity * 127,
                      note.durationTicks,
                    ].join('\t');
                  output += '\n';

                  output += JSON.stringify(z) + '\n';
                });
              }
            });
            t += 200;
            if (output) pre.innerHTML = output;

            await new Promise((r) => setTimeout(r, 500));
          }
        }
      }
    </script>
  </body>
</html>
